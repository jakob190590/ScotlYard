#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrreprt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\noun on
ScotlYard
\noun default

\begin_inset Newline newline
\end_inset

Entwicklerhandbuch
\end_layout

\begin_layout Author
Jakob Schöttl
\begin_inset Newline newline
\end_inset

jschoett@gmail.com
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Dieses Handbuch wendet sich an Entwickler, die ScotlYard in ihr Projekt
 einbinden oder weiterentwickeln wollen.
 Es beschreibt die Architektur, die Schnittstellen und die Standardimplementieru
ngen und wie diese verwendet werden.
\end_layout

\begin_layout Part
Architektur und Schnittstellen
\begin_inset Newline newline
\end_inset

ScotlYard (Core)
\end_layout

\begin_layout Chapter
Architektur
\end_layout

\begin_layout Section
Grundsätze
\end_layout

\begin_layout Itemize
GameState speichert den Spielverlauf und -zustand
\end_layout

\begin_layout Itemize
GameState informiert Listener über Änderungen
\end_layout

\begin_layout Itemize
Für GameState gibt es Proxies mit eingeschränktem Zugriff
\end_layout

\begin_layout Itemize
Eingeschränkte Moves zur Verfügung zu stellen ist Aufgabe des jeweiligen
 Proxys
\end_layout

\begin_layout Itemize
Game ist ein GameState, der Veränderungen zulässt
\end_layout

\begin_layout Itemize
GameController ist der einzige mit direktem Zugriff auf Game
\end_layout

\begin_layout Itemize
GameController verwaltet Model (GameState)
\end_layout

\begin_deeper
\begin_layout Itemize
er erzeugt Player
\end_layout

\begin_layout Itemize
GameState ändert sich nicht von selbst
\end_layout

\end_deeper
\begin_layout Itemize
GUI/Controller besitzen eine Instanz des GameControllers
\end_layout

\begin_layout Itemize
Rules und AI brauchen Default-Konstruktor (Class.forName(
\begin_inset Quotes gld
\end_inset

...
\begin_inset Quotes grd
\end_inset

).createInstance())
\end_layout

\begin_layout Itemize
AIs haben keine Ahnung von der Außenwelt und haben nur ihren persönlichen
 GameState und GameGraph
\end_layout

\begin_layout Itemize
DetectiveAI denkt für alle Detectives
\end_layout

\begin_layout Itemize
GameController ist Observable, um Clients über Änderungen des Spielzustands
 (GameStatus, GameWin) zu informieren
\end_layout

\begin_layout Itemize
Es ist nicht Aufgabe der Rules, einen inkonsistenten GameState zu bemerken
 (das wäre aussichtslos) -- aber wenn sie zufällig was merken: CorruptGameStateE
xception
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

To carry out a Move
\begin_inset Quotes grd
\end_inset

 heißt add(Move) 
\emph on
und
\emph default
 Current Player/Round weiterschalten
\end_layout

\begin_layout Itemize
Die Standardimplementierung ist stark an JGraphT gekoppelt
\end_layout

\begin_layout Chapter
Model
\end_layout

\begin_layout Standard
Das Model stellt -- wie bei der MVC-Architektur -- ein reines Datenmodell
 für das Spiel dar.
 Es ist dazu ausgelegt, den gesamten Spielverlauf und -zustand zu speichern.
 Das Model selbst ist nicht gefeit gegen Änderungen, die zu einem inkonsistenten
 Spielzustand führen.
\end_layout

\begin_layout Section
Spielzustand
\end_layout

\begin_layout Subsection
Die Schnittstelle GameState
\end_layout

\begin_layout Subsubsection
Zugriff auf Moves
\end_layout

\begin_layout Standard
Zum Zugriff auf die Moves gibt es folgende Methoden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List<Move> getMoves();
\end_layout

\begin_layout Plain Layout

Move getMove(Player p, int number, MoveAccessMode accessMode);
\end_layout

\begin_layout Plain Layout

Move getLastMove(Player p);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
getMoves liefert eine Liste mit Moves, die letzteren beiden sind eher convenient
 methods.
 Die Liste von getMoves sollte beim GameState unmodifiable sein.
 Außerdem muss die get Methode wie folgt implementiert sein:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Override
\end_layout

\begin_layout Plain Layout

public Move get(int index) {
\end_layout

\begin_layout Plain Layout

	return super.get((index >= 0) ?
\end_layout

\begin_layout Plain Layout

			index : 
\end_layout

\begin_layout Plain Layout

			size() + index);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dadurch wird mit negativen Indizes von hinten her auf die Listenelemente
 zugegriffen.
 Zu diesem Zweck gibt es auch noch eine Konstante des GameState:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* public static final */ int LAST_MOVE = -1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Somit kann also z.B.
 folgendermaßen auf die Moves zugegriffen werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import static GameState.LAST_MOVE;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(LAST_MOVE);     // letzter Zug
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(LAST_MOVE - 1); // vorletzter Zug
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(-2);  // ebenfalls vorletzter Zug
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mit getMove und getLastMove kann man dagegen auf einen Move eines bestimmten
 Players zugreifen.
 
\end_layout

\begin_layout Standard
getLastMove liefert einfach den letzten Zug des angegebeen Players.
\end_layout

\begin_layout Standard
getMove liefert -- abhängig vom MoveAccessMode (ROUND_NUMBER/MOVE_NUMBER)
 -- den entsprechenden Zug zu angegebenem Player und Nummer.
 Für die Nummer gilt auch hier wieder, dass negative Werte von hinten zählen.
 Dazu gibt es die Konstanten LAST_ROUND_NUMBER und LAST_MOVE_NUMBER des
 GameState, die wie LAST_MOVE definiert sind und ebenso verwendet werden.
\end_layout

\begin_layout Subsubsection
Copying und Gleichheit
\end_layout

\begin_layout Paragraph
Copying
\end_layout

\begin_layout Standard
Es ist praktisch, einen Spielzustand zu einem beliebigen Zeitpunkt festhalten
 zu können.
 Für die Tests der GameState-Implementierungen ist das nützlich, um 
\begin_inset Quotes gld
\end_inset

Vorher und Nachher
\begin_inset Quotes grd
\end_inset

 einfach vergleichen zu können.
 Aber auch um während dem Spiel einen Snapshot anzulegen, zu dem man später
 zurückkehren kann.
 Oder um ein Spiel aufzuspalten (
\begin_inset Quotes gld
\end_inset

fork
\begin_inset Quotes grd
\end_inset

) 
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
Zu diesem Zweck ist in Java eigentlich das Cloneable Interface gedacht,
 das -- wie ich es verstanden habe -- signalisiert, dass Object.clone() keine
 CloneNotSupportedException werfen soll.
 Allerdings ist die CloneNotSupportedException eine 
\begin_inset Quotes gld
\end_inset

checked
\begin_inset Quotes grd
\end_inset

 Exception, d.h.
 ich müsste jeden Aufruf von clone mit try-catch abschirmen, oder eine throws-De
klaration hinzufügen.
 Beides ist mir deutlich zu blöd, da GameStates das kopieren ausdrücklich
 unterstützen.
\end_layout

\begin_layout Standard
Darum habe ich die Methode public GameState copy() zur Schnittstelle hinzugefügt
, die eine Kopie des GameStates zurückliefern soll.
 Da die meisten GameStates Proxies eines GameStates sind, sollte die Implementie
rung im Normalfall etwa so aussehen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public GameState copy() {
\end_layout

\begin_layout Plain Layout

	return new ThisGameStateProxy(
\end_layout

\begin_layout Plain Layout

			gameState.copy());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dabei ist ThisGameStateProxy die Klasse des Objekts, von dem eine Kopie
 erzeugt werden soll, und gameState das 
\begin_inset Quotes gld
\end_inset

RealSubject
\begin_inset Quotes grd
\end_inset

, an das die Methodenaufrufe mehr oder weniger deligiert werden.
\end_layout

\begin_layout Standard
Nur beim Game (ganz am Ende der Kette von Proxies), werden wirklich Daten
 kopiert! Diese Daten sind z.B.
 die MoveList, DetectiveList, Maps usw.
\end_layout

\begin_layout Paragraph
Gleichheit
\end_layout

\begin_layout Standard
Wenn kopiert wird, müssen das ursprüngliche Objekt und die Kopie natürlich
 
\begin_inset Quotes gld
\end_inset

gleich
\begin_inset Quotes grd
\end_inset

 sein.
 Zu diesem Zweck wird im AbstractGameState die Methode equals so überschrieben,
 dass sie die Werte der Getter vergleicht.
\end_layout

\begin_layout Standard
Zu diesen Gettern gehören aber nur die Notwendigen, nämlich die, die direkt
 Daten liefern und nicht Ergebnisse berechnen.
 getPlayers, getMove und getLastMove zählen also nicht, weil diese fest
 definierte Aufgaben haben und ihre Ergebnisse nur aus den Werten der übrigen
 Getter berechnen.
\end_layout

\begin_layout Standard
getItems braucht leider eine Sonderbehandlung.
 Diese Methode soll direkt einen Set von Items für einen bestimmten Player
 liefern.
 Um das GameState Interface möglichst einfach zu gestalten (in Hinsicht
 auf Implementierung und Nutzung) habe ich eben darauf verzichtet, die Map<Playe
r, Set<Item>> direkt bereitzustellen.
 Das Problem beim Vergleich ist nun, dass nicht die Map verglichen werden
 kann, sondern nur Ergebnisse von getItems.
 Es ist jetzt so gelöst, dass die Ergebnisse von getItems für alle Player
 aus getPlayers() auf Gleichheit getestet werden.
 Übrige Sets in der Map werden ignoriert, weil erstens ohne Schlüssel gar
 nicht darauf zugegriffen werden kann und zweitens diese eigentlich sowieso
 nichts mehr im GameState verloren haben.
\end_layout

\begin_layout Subsection
Die Schnittstelle Game
\end_layout

\begin_layout Section
Spielgraph
\end_layout

\begin_layout Standard
Der Graph modelliert das Spielfeld.
 Er ist nicht Teil der Regeln, sondern wird gesondert erzeugt.
 Die Regeln haben nämlich auch kaum etwas mit dem konkreten Graphen zu tun.
 Die einzige Ausnahme ist in der GameInitPolicy die Methode suggestInitialStatio
n.
 Diese muss aus möglichen Startpositionen für den gegebenen Spieler eine
 auswählen.
 Die möglichen Startpositionen hängen aber eng mit dem konkreten Graph zusammen.
 Daher wird in diesem Ausnahmefall zusätzlich zum GameGraph noch eine Menge
 an möglichen Startpositionen übergeben (Set<StationVertex>).
 Diese möglichen Startpositionen gehören also auch eher zum Spielgraph und
 sind nicht Teil der Regeln.
\end_layout

\begin_layout Standard
Im folgenden werden zwei Begriffe verwendet:
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

Original Graph-Schnittstelle
\begin_inset Quotes grd
\end_inset

 ist die Graph-Schnittstelle des verwendeten Graph-Toolkits.
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

GameGraph Schnittstelle
\begin_inset Quotes grd
\end_inset

 ist die Graph-Schnittstelle, mit der innerhalb ScotlYard gearbeitet wird.
\end_layout

\begin_layout Subsection
Einbindung des Graph-Toolkits
\end_layout

\begin_layout Standard
Für die Einbindung eines Gaph-Toolkits gibt es mehrere Möglichkeiten.
 Mir sind vier Möglichkeiten eingefallen, davon hat mir aber nur eine gefallen.
 Die vier Möglichkeiten sind:
\end_layout

\begin_layout Enumerate
Eine echte Bridge (siehe Bridge pattern), nicht nur bei StationVertex und
 ConnectionEdge, sondern auch bei der GameGraph Schnittstelle.
\end_layout

\begin_layout Enumerate
GameGraph als Erweiterung (extends) der original Graph-Schnittstelle des
 Toolkits.
 Dazu einen 1:1-Proxy
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Damit meine ich einen Proxy, der in jeder Methode wirklich nichts anderes
 macht, als die selbe Methode am RealSubject aufzurufen.
\end_layout

\end_inset

 (siehe Proxy pattern) als Subclass von GameGraph definieren, weil ja eine
 Standardimplementierung der original Graph-Schnittstelle leider keine Instanz
 der GameGraph Schnittstelle sein kann.
\end_layout

\begin_layout Enumerate
Auf GameGraph verzichten und überall direkt die original Graph-Schnittstelle
 verwenden.
\end_layout

\begin_layout Enumerate
GameGraph als Wrapper class mit einer Methode getGraph, die eine Instanz
 der original Graph-Schnittstelle zurückgibt.
 Der 
\begin_inset Quotes gld
\end_inset

Umschlag
\begin_inset Quotes grd
\end_inset

 kann herumgereicht werden und der Graph wird nur da herausgeholt, wo er
 wirklich gebraucht wird.
\end_layout

\begin_layout Standard
Ich habe mich aus folgenden Gründen für die vierte Möglichkeit (GameGraph
 als Wrapper class) entschieden:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

1.
 Entfällt, weil
\end_layout

\begin_deeper
\begin_layout Itemize
ich dann eine vollständige eigene Graph-Schnittstelle definieren müsste,
 aber ja gar nicht den Graph-Toolkit-Entwickler spielen möchte und
\end_layout

\begin_layout Itemize
Vorteile durch den Einsatz eines anderen Graph-Toolkits nur genutzt werden
 können, wenn ich meine Schnittstelle erweitere.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

2.
 Entfällt, weil
\end_layout

\begin_deeper
\begin_layout Itemize
ein 1:1-Proxy eine ziemlich stupide Programmierarbeit ist,
\end_layout

\begin_layout Itemize
trotzdem eine weitere Möglichkeit bietet, Fehler zu machen und
\end_layout

\begin_layout Itemize
es einfach unnötig und unschön ist.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

3.
 Entfällt, weil bei Austausch des Graph-Toolkits im ganzen Projekt hunderte
 Änderungen des Typs nötig wären, auch wenn die GameGraph Schnittstelle
 nicht mal verwendet wird, sondern der Graph nur herumgereicht wird.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

4.
 Damit muss der Code bei Austausch des Toolkits nur an den Stellen geändert
 werden, wo tatsächlich auf die original Graph-Schnittstelle zugegriffen
 wird (und natürlich im GameGraph).
\end_layout

\begin_layout Subsection

\noun on
JGraphT
\end_layout

\begin_layout Standard
Als Graph-Toolkit kommt JGraphT zum Einsatz.
 JGraphT bietet mit der Schnittstelle UndirectedGraph<V, E> Zugriff auf
 ungerichtete Graphen.
 Als Standardimplementierung kommt MultiGraph
\begin_inset Note Note
status open

\begin_layout Plain Layout
ja, wirklich?
\end_layout

\end_inset

<V, E> in Frage.
\end_layout

\begin_layout Subsection
Aufwand bei Wechsel des Graph-Toolkits
\end_layout

\begin_layout Standard
Das JGraphT-Toolkit ist relativ eng mit ScotlYard gekoppelt.
 Trotzdem ist es möglich, ein anderes Toolkit zu verwenden, ohne die Architektur
 oder Schnittstellen verändern zu müssen.
 Die Anpassungen, die durchgeführt werden müssen, beschränken sich fast
 ausschließlich auf die Implementierung.
 Im folgenden werden Vorraussetzungen und nötige Anpassungen näher beschrieben.
\end_layout

\begin_layout Subsubsection
Vorraussetzungen an das Graph-Toolkit
\end_layout

\begin_layout Standard
Folgende wenige Vorraussetzungen muss das Toolkit erfüllen:
\end_layout

\begin_layout Enumerate
Es muss 
\emph on
eine
\emph default
 Schnittstelle bereitstellt, über die man auf den gesamten Graphen zugreifen
 kann.
\end_layout

\begin_layout Enumerate
Es muss es erlauben, für Knoten beliebige eigene Objekte einer Klasse festzulege
n.
\end_layout

\begin_layout Enumerate
Es muss es erlauben, für Kanten beliebige eigene Objekte einer Klasse festzulege
n.
\end_layout

\begin_layout Subsubsection
Grundlage
\end_layout

\begin_layout Standard
Die grundlegendsten Anpassung müssen im Package kj.scotlyard.game.graph gemacht
 werden.
\end_layout

\begin_layout Enumerate
Zunächst müssen im GameGraph alle Vorkommen von
\begin_inset Newline newline
\end_inset

org.jgrapht.UndirectedGraph<StationVertex, ConnectionEdge>
\begin_inset Newline newline
\end_inset

abgeändert werden zur Graph-Schnittstelle des verwendeten Toolkits
\begin_inset Newline newline
\end_inset

OtherToolkitsGraphInterface<StationVertex, ConnectionEdge>
\end_layout

\begin_layout Enumerate
Außerdem definieren die Schnittstellen StationVertex und ConnectionEdge
 grundlegende Methoden, die den Zugriff auf den Graph vereinfachen und vereinhei
tlichen (siehe Bridge pattern).
 Die Implementierung in Station und Connection verwendet die original Graph-Schn
ittstelle, und muss bei Verwendung eines anderen Toolkits natürlich anders
 aussehen.
\end_layout

\begin_layout Subsubsection
Keine Änderungen im Model
\end_layout

\begin_layout Standard
Im Model (kj.scotlyard.game.model.*) muss nichts verändert werden, denn diese
 Klassen beziehen sich ausschließlich auf Knoten und Kanten des Graphen
 -- und diese sind ja in ScotlYard definiert; der Graph strukturiert sie
 nur.
\end_layout

\begin_layout Subsubsection
Keine Änderungen im Controller
\end_layout

\begin_layout Standard
Im Controller (kj.scotlyard.game.control.*) muss ebenfalls nichts verändert
 werden.
 Diese Klassen beziehen sich nur auf das Model und wenden dabei Regeln an.
 Den Regeln muss der Graph (in Form des GameGraph) zwar übergeben werden,
 aber was sich hinter GameGraph verbirgt interessiert den Controller nicht.
\end_layout

\begin_layout Subsubsection
Änderungen in Regeln
\end_layout

\begin_layout Standard
Das Interface in kj.scotlyard.game.rules.* ändert sich ebenfalls nicht.
 In der Implementierung der Regeln wird aber under Umständen auf den Graphen
 zugegriffen, denn die Regeln testen zum Beispiel, ob durch einen Zug der
 angegebene Knoten überhaupt erreichbar ist.
\end_layout

\begin_layout Standard
Würde die Implementierung mit dem Interface von StationVertex und ConnectionEdge
 auskommen, wären auch hier keine Änderungen notwendig.
 Wird aber auf das Interface der original Graph-Schnittstelle zurückgegriffen,
 müssen Anpassungen durchgeführt werden.
\end_layout

\begin_layout Subsubsection
Änderungen in AI
\end_layout

\begin_layout Standard
Auch hier ändern sich die Schnittstellen in kj.scotlyard.game.ai.* nicht, die
 Implementierung aber wahrscheinlich schon.
 Die AI lebt schließlich von Operationen im Graph und wird sich dabei nicht
 auf die schmale Schnittstelle von StationVertex und ConnectionEdge beschränken.
\end_layout

\begin_layout Subsubsection
Änderungen in Utilities
\end_layout

\begin_layout Standard
Einige Utilities (kj.scotlyard.game.utils.*), die eventuell mit dem GameGraph
 arbeiten, müssen angepasst werden.
 Dazu gehört vielleicht der MrXTracker.
\end_layout

\begin_layout Chapter
Controller und Rules
\end_layout

\begin_layout Standard
Der Controller steuert den Zugriff auf das Model.
 Er verhindert, dass es zu einem inkonsistenten Zustand im Model kommt,
 indem er die Regeln anwendet.
\end_layout

\begin_layout Section
Regeln
\end_layout

\begin_layout Subsection
Grundprinzipien
\end_layout

\begin_layout Standard
Es muss wenige Grundprinzipien im Spiel geben, damit Regeln überhaupt sinn
 machen und die Abtrennung vom Rest funktioniert.
\end_layout

\begin_layout Subsection
Anwendung der Regeln
\end_layout

\begin_layout Subsubsection
Spielbeginn
\end_layout

\begin_layout Subsubsection
Spielzüge
\end_layout

\begin_layout Itemize
movePolicy.checkMove(gameState, move)
\end_layout

\begin_layout Itemize
Items weitergeben: movePolcy.getNextItemOwner(gameState, move, item)
\end_layout

\begin_layout Itemize
Move zur Liste hinzufügen: gameState.getMoves().add(move)
\end_layout

\begin_layout Itemize
gameWinPolicy.isGameWon(gameState, gameGraph)
\end_layout

\begin_layout Itemize
turnPolicy.getNextPlayer/getNextRoundNumber
\end_layout

\begin_layout Itemize
gameState.setCurrentPlayer/setCurrentRoundNumber
\end_layout

\begin_layout Itemize
gameController.setState(gameStatus, gameWin)
\end_layout

\begin_layout Subsubsection
Spielende
\end_layout

\begin_layout Chapter
AI
\end_layout

\begin_layout Standard
Die künstliche Intelligenz kann für Detectives oder MrX Spielzüge vorschlagen.
\end_layout

\begin_layout Chapter
Utilities
\end_layout

\begin_layout Part
Standardimplementierung
\begin_inset Newline newline
\end_inset

(
\begin_inset Quotes gld
\end_inset

The Scotland Yard
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout Section
Begriffe
\end_layout

\begin_layout Itemize
Initial Move
\end_layout

\begin_layout Itemize
Single Move
\end_layout

\begin_layout Itemize
Multi Move
\end_layout

\begin_layout Itemize
Base Move
\end_layout

\begin_layout Itemize
Sub Move
\end_layout

\begin_layout Part*
Anhang
\end_layout

\begin_layout Section
Eigennamen
\end_layout

\begin_layout Itemize
ScotlYard
\end_layout

\begin_layout Itemize
Board
\end_layout

\begin_layout Itemize
JGraphT
\end_layout

\end_body
\end_document
