#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrreprt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "ScotlYard Entwicklerhandbuch"
\pdf_author "Jakob Schöttl"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\noun on
ScotlYard
\noun default

\begin_inset Newline newline
\end_inset

Entwicklerhandbuch
\end_layout

\begin_layout Author
Jakob Schöttl
\begin_inset Newline newline
\end_inset

jschoett@gmail.com
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Dieses Handbuch wendet sich an Entwickler, die ScotlYard in ihr Projekt
 einbinden oder weiterentwickeln wollen.
 Es beschreibt die Architektur, die Schnittstellen und die Standardimplementieru
ngen und wie diese verwendet werden.
\end_layout

\begin_layout Part
Architektur und Schnittstellen
\begin_inset Newline newline
\end_inset

ScotlYard (Core)
\end_layout

\begin_layout Chapter
Architektur
\end_layout

\begin_layout Section
Grundsätze
\end_layout

\begin_layout Itemize
GameState speichert den Spielverlauf und -zustand
\end_layout

\begin_layout Itemize
GameState informiert Listener über Änderungen
\end_layout

\begin_layout Itemize
Für GameState gibt es Proxies mit eingeschränktem Zugriff
\end_layout

\begin_layout Itemize
Eingeschränkte Moves zur Verfügung zu stellen ist Aufgabe des jeweiligen
 Proxys
\end_layout

\begin_layout Itemize
Game ist ein GameState, der Veränderungen zulässt
\end_layout

\begin_layout Itemize
GameController ist der einzige mit direktem Zugriff auf Game
\end_layout

\begin_layout Itemize
GameController verwaltet Model (GameState)
\end_layout

\begin_deeper
\begin_layout Itemize
er erzeugt Player
\end_layout

\begin_layout Itemize
GameState ändert sich nicht von selbst
\end_layout

\end_deeper
\begin_layout Itemize
GUI/Controller besitzen eine Instanz des GameControllers
\end_layout

\begin_layout Itemize
Rules und AI brauchen Default-Konstruktor (Class.forName(
\begin_inset Quotes gld
\end_inset

...
\begin_inset Quotes grd
\end_inset

).createInstance())
\end_layout

\begin_layout Itemize
AIs haben keine Ahnung von der Außenwelt und haben nur ihren persönlichen
 GameState und GameGraph
\end_layout

\begin_layout Itemize
DetectiveAI denkt für alle Detectives
\end_layout

\begin_layout Itemize
GameController ist Observable, um Clients über Änderungen des Spielzustands
 (GameStatus, GameWin) zu informieren
\end_layout

\begin_layout Itemize
Es ist nicht Aufgabe der Rules, einen inkonsistenten GameState zu bemerken
 (das wäre aussichtslos) -- aber wenn sie zufällig was merken: CorruptGameStateE
xception
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

To carry out a Move
\begin_inset Quotes grd
\end_inset

 heißt add(Move) 
\emph on
und
\emph default
 Current Player/Round weiterschalten
\end_layout

\begin_layout Itemize
Die Standardimplementierung ist stark an JGraphT gekoppelt
\end_layout

\begin_layout Chapter
Model
\end_layout

\begin_layout Standard
Das Model stellt -- wie bei der MVC-Architektur -- ein reines Datenmodell
 für das Spiel dar.
 Es ist dazu ausgelegt, den gesamten Spielverlauf und -zustand zu speichern.
 Das Model selbst ist nicht gefeit gegen Änderungen, die zu einem inkonsistenten
 Spielzustand führen.
\end_layout

\begin_layout Section
Spielzustand
\end_layout

\begin_layout Subsection
Move
\end_layout

\begin_layout Standard
Ein Move stellt den Zug eines Spielers dar.
 Wir unterscheiden zwischen:
\end_layout

\begin_layout Itemize
SingleMove
\begin_inset Newline newline
\end_inset

Diese Art hat keine weiteren SubMoves und ist bei Scotland Yard der Normalfall
 für Detektive.
\end_layout

\begin_layout Itemize
MultiMove
\begin_inset Newline newline
\end_inset

Diese Art besitzt weitere SubMoves; Bei Scotland Yard genau zwei: Ein Doppelzug
 des Mr.
 X.
\end_layout

\begin_layout Itemize
BaseMove
\begin_inset Newline newline
\end_inset

Bezeichnet allein den MultiMove, ohne seine SubMoves.
\end_layout

\begin_layout Itemize
SubMove
\begin_inset Newline newline
\end_inset

Diese Art beschreibt Moves, die in einen MultiMove eingebettet sind.
 Bei Scotland Yard müssen SubMoves immer auch SingleMoves sein.
 Eine Hierarchie tiefer als zwei gibt es dort nicht.
\end_layout

\begin_layout Standard
Zur Identifikation eines Moves gibt es drei Zahlenwerte.
 Alle drei Zahlen beginnen jeweils bei 0
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Für 1.
 und 2.
 festgelegt durch die Konstanten INITIAL_MOVE_NUMBER und INITIAL_ROUND_NUMBER
 in GameState.
 Für 3.
 durch das Wort 
\begin_inset Quotes gld
\end_inset

Index
\begin_inset Quotes grd
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
MoveNumber
\begin_inset Newline newline
\end_inset

Die MoveNumber nummeriert alle SingleMoves eines Spielers durch.
 Bei Moves, die keine SingleMoves sind (d.h.
 z.B.
 der BaseMove eines MultiMoves), gibt es keine MoveNumber; Der Wert ist
 dann GameState.NO_MOVE_NUMBER (-1).
\end_layout

\begin_layout Enumerate
RoundNumber
\begin_inset Newline newline
\end_inset

Die RoundNumber (Rundennummer) ist für alle Moves einer Runde gleich (z.B.
 MultiMove und alle seine SubMoves).
\end_layout

\begin_layout Enumerate
MoveIndex
\begin_inset Newline newline
\end_inset

Der MoveIndex ist nur bei MultiMoves von Bedeutung.
 Er nummieriert die SubMoves durch.
 Bei BaseMoves oder bei SingleMoves, die keine SubMoves sind, ist der MoveIndex
 GameState.NO_MOVE_INDEX (-1).
\end_layout

\begin_layout Standard
Zur komfortablen Erzeugung von Moves stehen die Util-Klassen MoveProducer
 (Factory) und SubMoves (Builder, der dann der Factory-Methode des MoveProducers
 als Argument übergeben wird) zur Verfügung.
\end_layout

\begin_layout Subsection
Die Schnittstelle GameState
\end_layout

\begin_layout Subsubsection
Zugriff auf Moves
\end_layout

\begin_layout Standard
Zum Zugriff auf die Moves gibt es folgende Methoden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List<Move> getMoves();
\end_layout

\begin_layout Plain Layout

Move getMove(Player p, int number, MoveAccessMode accessMode);
\end_layout

\begin_layout Plain Layout

Move getLastMove(Player p);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
getMoves liefert eine Liste mit Moves, die letzteren beiden sind eher convenient
 methods.
 Die Liste von getMoves sollte beim GameState unmodifiable sein.
 Außerdem muss die get Methode wie folgt implementiert sein:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Override
\end_layout

\begin_layout Plain Layout

public Move get(int index) {
\end_layout

\begin_layout Plain Layout

	return super.get((index >= 0) ?
\end_layout

\begin_layout Plain Layout

			index : 
\end_layout

\begin_layout Plain Layout

			size() + index);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dadurch wird mit negativen Indizes von hinten her auf die Listenelemente
 zugegriffen.
 Zu diesem Zweck gibt es auch noch eine Konstante des GameState:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* public static final */ int LAST_MOVE = -1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Somit kann also z.B.
 folgendermaßen auf die Moves zugegriffen werden:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import static GameState.LAST_MOVE;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(LAST_MOVE);     // letzter Zug
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(LAST_MOVE - 1); // vorletzter Zug
\end_layout

\begin_layout Plain Layout

gs.getMoves().get(-2);  // ebenfalls vorletzter Zug
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mit getMove und getLastMove kann man dagegen auf einen Move eines bestimmten
 Players zugreifen.
 
\end_layout

\begin_layout Standard
getLastMove liefert einfach den letzten Zug des angegebeen Players.
\end_layout

\begin_layout Standard
getMove liefert -- abhängig vom MoveAccessMode (ROUND_NUMBER/MOVE_NUMBER)
 -- den entsprechenden Zug zu angegebenem Player und Nummer.
 Für die Nummer gilt auch hier wieder, dass negative Werte von hinten zählen.
 Dazu gibt es die Konstanten LAST_ROUND_NUMBER und LAST_MOVE_NUMBER des
 GameState, die wie LAST_MOVE definiert sind und ebenso verwendet werden.
\end_layout

\begin_layout Subsubsection
Copying und Gleichheit
\end_layout

\begin_layout Paragraph
Copying
\end_layout

\begin_layout Standard
Es ist praktisch, einen Spielzustand zu einem beliebigen Zeitpunkt festhalten
 zu können.
 Für die Tests der GameState-Implementierungen ist das nützlich, um 
\begin_inset Quotes gld
\end_inset

Vorher und Nachher
\begin_inset Quotes grd
\end_inset

 einfach vergleichen zu können.
 Aber auch um während dem Spiel einen Snapshot anzulegen, zu dem man später
 zurückkehren kann.
 Oder um ein Spiel aufzuspalten (
\begin_inset Quotes gld
\end_inset

fork
\begin_inset Quotes grd
\end_inset

) 
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
Zu diesem Zweck ist in Java eigentlich das Cloneable Interface gedacht,
 das -- wie ich es verstanden habe -- signalisiert, dass Object.clone() keine
 CloneNotSupportedException werfen soll.
 Allerdings ist die CloneNotSupportedException eine 
\begin_inset Quotes gld
\end_inset

checked
\begin_inset Quotes grd
\end_inset

 Exception, d.h.
 ich müsste jeden Aufruf von clone mit try-catch abschirmen, oder eine throws-De
klaration hinzufügen.
 Beides ist mir deutlich zu blöd, da GameStates das kopieren ausdrücklich
 unterstützen.
\end_layout

\begin_layout Standard
Darum habe ich die Methode public GameState copy() zur Schnittstelle hinzugefügt
, die eine Kopie des GameStates zurückliefern soll.
 Da die meisten GameStates Proxies eines GameStates sind, sollte die Implementie
rung im Normalfall etwa so aussehen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public GameState copy() {
\end_layout

\begin_layout Plain Layout

	return new ThisGameStateProxy(
\end_layout

\begin_layout Plain Layout

			gameState.copy());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dabei ist ThisGameStateProxy die Klasse des Objekts, von dem eine Kopie
 erzeugt werden soll, und gameState das 
\begin_inset Quotes gld
\end_inset

RealSubject
\begin_inset Quotes grd
\end_inset

, an das die Methodenaufrufe mehr oder weniger deligiert werden.
\end_layout

\begin_layout Standard
Nur beim Game (ganz am Ende der Kette von Proxies), werden wirklich Daten
 kopiert! Diese Daten sind z.B.
 die MoveList, DetectiveList, Maps usw.
\end_layout

\begin_layout Paragraph
Gleichheit
\end_layout

\begin_layout Standard
Wenn kopiert wird, müssen das ursprüngliche Objekt und die Kopie natürlich
 
\begin_inset Quotes gld
\end_inset

gleich
\begin_inset Quotes grd
\end_inset

 sein.
 Zu diesem Zweck wird im AbstractGameState die Methode equals so überschrieben,
 dass sie die Werte der Getter vergleicht.
\end_layout

\begin_layout Standard
Zu diesen Gettern gehören aber nur die Notwendigen, nämlich die, die direkt
 Daten liefern und nicht Ergebnisse berechnen.
 getPlayers, getMove und getLastMove zählen also nicht, weil diese fest
 definierte Aufgaben haben und ihre Ergebnisse nur aus den Werten der übrigen
 Getter berechnen.
\end_layout

\begin_layout Standard
getItems braucht leider eine Sonderbehandlung.
 Diese Methode soll direkt einen Set von Items für einen bestimmten Player
 liefern.
 Um das GameState Interface möglichst einfach zu gestalten (in Hinsicht
 auf Implementierung und Nutzung) habe ich eben darauf verzichtet, die Map<Playe
r, Set<Item>> direkt bereitzustellen.
 Das Problem beim Vergleich ist nun, dass nicht die Map verglichen werden
 kann, sondern nur Ergebnisse von getItems.
 Es ist jetzt so gelöst, dass die Ergebnisse von getItems für alle Player
 aus getPlayers() auf Gleichheit getestet werden.
 Übrige Sets in der Map werden ignoriert, weil erstens ohne Schlüssel gar
 nicht darauf zugegriffen werden kann und zweitens diese eigentlich sowieso
 nichts mehr im GameState verloren haben.
\end_layout

\begin_layout Subsection
Die Schnittstelle Game
\end_layout

\begin_layout Section
Spielgraph
\end_layout

\begin_layout Standard
Der GameGraph modelliert das Spielfeld.
 Er enthält den Graph und die Initial Stations (mögliche Startpositionen).
 Das public-Interface sieht folgendermaßen aus:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GraphInterface getGraph();
\end_layout

\begin_layout Plain Layout

Set<StationVertex> getInitialStations();
\end_layout

\begin_layout Plain Layout

void setGraph(GraphInterface graph);
\end_layout

\begin_layout Plain Layout

void setInitialStations(Set<StationVertex> initialStations);
\end_layout

\begin_layout Plain Layout

void seal();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden Graph und Initial Stations gesetzt.
 Anschließen wird der GameGraph mit seal 
\begin_inset Quotes gld
\end_inset

sealed & released
\begin_inset Quotes grd
\end_inset

.
 Das bedeutet, dass alle seine Daten werden unmodifiable gemacht werden
 (in jeder Hinsicht) und er zur Benutzung freigegeben wird.
\begin_inset Foot
status open

\begin_layout Plain Layout
Diese Verkomplizierung des Interface ist leider notwendig.
 Man könnte sich fragen 
\begin_inset Quotes gld
\end_inset

warum werden die Werte nicht per Konstruktor übergeben, dann könnte man
 sich das Sealable sparen
\begin_inset Quotes grd
\end_inset

.
 Das geht aber nicht aus folgendem Grund: Die Elemente des Graph (StationVertex/
ConnectionEdge) erwarten im Konstruktor einen GameGraph (damit sie als einfache
 Bridge fungieren können).
 Das heißt, beim Erstellen des Graph muss der GameGraph schon existieren.
 Auch die Initial Stations können erst hinzugefügt werden, wenn der Graph
 existiert.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der GameGraph ist nicht Teil der Regeln, sondern wird gesondert erzeugt.
 Die Regeln haben nämlich kaum etwas mit dem konkreten Graphen zu tun.
 Die einzige Ausnahme ist in der GameInitPolicy die Methode suggestInitialStatio
n.
 Diese muss aus möglichen Startpositionen für den gegebenen Spieler eine
 auswählen.
 Die möglichen Startpositionen hängen aber eng mit dem konkreten Graph zusammen.
 Also gehören sie zum GameGraph und sind nicht Teil der Regeln.
 Sie werden den Regeln per GameGraph übergeben.
\end_layout

\begin_layout Standard
Im Folgenden werden zwei Begriffe verwendet:
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

Original Graph-Schnittstelle
\begin_inset Quotes grd
\end_inset

 ist die Graph-Schnittstelle des verwendeten Graph-Toolkits (z.B.
 UndirectedGraph bei JGraphT).
\end_layout

\begin_layout Itemize
\begin_inset Quotes gld
\end_inset

GameGraph Schnittstelle
\begin_inset Quotes grd
\end_inset

 ist die Graph-Schnittstelle, mit der innerhalb ScotlYard gearbeitet wird.
\end_layout

\begin_layout Subsection
Erzeugung des GameGraph
\end_layout

\begin_layout Standard
Zur Erzeugung des GameGraph stehen im Projekt GraphBuilder und Board entsprechen
de Builder zur Verfügung.
 Die Builder-Schnittstelle ist durch das Interface GraphBuilder vorgegeben.
 Das Erzeugen des GameGraph läuft folgendermaßen ab (siehe auch Builder
 Pattern):
\end_layout

\begin_layout Enumerate
Der Director lässt den Builder den GameGraph bauen.
\end_layout

\begin_layout Enumerate
Der Client holt das Erzeugnis dann vom Builder ab (per getGameGraph).
 Der GameGraph ist noch modifiable, da die Initial Stations noch fehlen.
\end_layout

\begin_layout Enumerate
Der Client stellt den GameGraph fertig, d.h.
 er setzt die Initial Stations.
\end_layout

\begin_layout Enumerate
Der Client ruft die Methode seal auf, um den Graphen, die Initial Stations
 und den GameGraph selbst zu versiegeln (
\begin_inset Quotes gld
\end_inset

seal & release
\begin_inset Quotes grd
\end_inset

).
 Der GameGraph ist nun fertig.
\end_layout

\begin_layout Standard
Als Director steht die Klasse kj.scotlyard.graphbuilder.builder.Director zur
 Verfügung, die anhand der Graph Description (Datei) dem Builder Anweisungen
 gibt.
 Ein Client ist im Projekt Board der BoardGraphLoader, der als konkreten
 Builder den BoardGraphBuilder verwendet.
 Als Director verwendet der BoardGraphLoader intern den eben vorgestellten
 Director.
\end_layout

\begin_layout Standard
Gespeichert ist der GameGraph in einfachen Textdateien.
 Der Graph in der sogenannten Graph Description, die Initial Stations in
 einer zweiten Datei.
 Die Graph Description besteht aus Zeilen.
 Jede Zeile stellt entweder einen Knoten (Vertex) oder eine Kante (Edge)
 dar.
 Am Anfang steht V oder E zur Unterscheidung, gefolgt vom vollständigen
 Klassennamen.
 Bei Knoten folgen Vertex-Nummer und normierte x/y-Koordinaten (von links
 oben).
 Bei Kanten folgenden die Vertex-Nummern der Knoten, die sie verbindet (bei
 gerichteten Graphen von der ersten Vertex-Nummer zur zweiten Vertex-Nummer).
 Ein Auszug zur Veranschaulichung:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

V kj.scotlyard.game.graph.Station 181 0.33534743202416917 0.8195488721804511
\end_layout

\begin_layout Plain Layout

E kj.scotlyard.game.graph.connection.BusConnection 161 135
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Initial Stations-Datei beinhaltet die Vertex-Nummern der Startpositionen,
 durch Whitespace getrennt.
\end_layout

\begin_layout Subsection
Einbindung des Graph-Toolkits
\end_layout

\begin_layout Standard
Für die Einbindung eines Gaph-Toolkits gibt es mehrere Möglichkeiten.
 Mir sind vier Möglichkeiten eingefallen, davon hat mir aber nur eine gefallen.
 Die vier Möglichkeiten sind:
\end_layout

\begin_layout Enumerate
Eine echte Bridge (siehe Bridge pattern), nicht nur bei StationVertex und
 ConnectionEdge, sondern auch bei der GameGraph Schnittstelle.
\end_layout

\begin_layout Enumerate
GameGraph als Erweiterung (extends) der original Graph-Schnittstelle des
 Toolkits.
 Dazu einen 1:1-Proxy
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Damit meine ich einen Proxy, der in jeder Methode wirklich nichts anderes
 macht, als die selbe Methode am RealSubject aufzurufen.
\end_layout

\end_inset

 (siehe Proxy pattern) als Subclass von GameGraph definieren, weil ja eine
 Standardimplementierung der original Graph-Schnittstelle leider keine Instanz
 der GameGraph Schnittstelle sein kann.
\end_layout

\begin_layout Enumerate
Auf GameGraph verzichten und überall direkt die original Graph-Schnittstelle
 verwenden.
\end_layout

\begin_layout Enumerate
GameGraph als Wrapper class mit einer Methode getGraph, die eine Instanz
 der original Graph-Schnittstelle zurückgibt.
 Der 
\begin_inset Quotes gld
\end_inset

Umschlag
\begin_inset Quotes grd
\end_inset

 kann herumgereicht werden und der Graph wird nur da herausgeholt, wo er
 wirklich gebraucht wird.
\end_layout

\begin_layout Standard
Ich habe mich aus folgenden Gründen für die vierte Möglichkeit (GameGraph
 als Wrapper class) entschieden:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

1.
 Entfällt, weil
\end_layout

\begin_deeper
\begin_layout Itemize
ich dann eine vollständige eigene Graph-Schnittstelle definieren müsste,
 aber ja gar nicht den Graph-Toolkit-Entwickler spielen möchte und
\end_layout

\begin_layout Itemize
Vorteile durch den Einsatz eines anderen Graph-Toolkits nur genutzt werden
 können, wenn ich meine Schnittstelle erweitere.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

2.
 Entfällt, weil
\end_layout

\begin_deeper
\begin_layout Itemize
ein 1:1-Proxy eine ziemlich stupide Programmierarbeit ist,
\end_layout

\begin_layout Itemize
trotzdem eine weitere Möglichkeit bietet, Fehler zu machen und
\end_layout

\begin_layout Itemize
es einfach unnötig und unschön ist.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Zu
\begin_inset space ~
\end_inset

3.
 Entfällt, weil bei Austausch des Graph-Toolkits im ganzen Projekt hunderte
 Änderungen des Typs nötig wären, auch wenn die GameGraph Schnittstelle
 nicht mal verwendet wird, sondern der Graph nur herumgereicht wird.
 Zu
\begin_inset space ~
\end_inset

4.
 Damit muss der Code bei Austausch des Toolkits nur an den Stellen geändert
 werden, wo tatsächlich auf die original Graph-Schnittstelle zugegriffen
 wird (und natürlich im GameGraph).
\end_layout

\begin_layout Subsection

\noun on
JGraphT
\end_layout

\begin_layout Standard
Als Graph-Toolkit kommt JGraphT zum Einsatz.
 JGraphT bietet mit der Schnittstelle UndirectedGraph<V, E> Zugriff auf
 ungerichtete Graphen.
 Als Standardimplementierung kommt UnmodifiableUndirectedGraph<V, E> in
 Frage.
\end_layout

\begin_layout Subsection
Aufwand bei Wechsel des Graph-Toolkits
\end_layout

\begin_layout Standard
Das JGraphT-Toolkit ist relativ eng mit ScotlYard gekoppelt.
 Trotzdem ist es möglich, ein anderes Toolkit zu verwenden, ohne die Architektur
 oder Schnittstellen verändern zu müssen.
 Die Anpassungen, die durchgeführt werden müssen, beschränken sich fast
 ausschließlich auf Teile der Implementierung.
 Im folgenden werden Vorraussetzungen und nötige Anpassungen näher beschrieben.
\end_layout

\begin_layout Subsubsection
Vorraussetzungen an das Graph-Toolkit
\end_layout

\begin_layout Standard
Folgende wenige Vorraussetzungen muss das Toolkit erfüllen:
\end_layout

\begin_layout Enumerate
Es muss 
\emph on
eine
\emph default
 Schnittstelle bereitstellt, über die man auf den gesamten Graphen zugreifen
 kann.
\end_layout

\begin_layout Enumerate
Es muss es erlauben, für Knoten beliebige eigene Objekte einer Klasse festzulege
n.
\end_layout

\begin_layout Enumerate
Es muss es erlauben, für Kanten beliebige eigene Objekte einer Klasse festzulege
n.
\end_layout

\begin_layout Subsubsection
Grundlage
\end_layout

\begin_layout Standard
Die grundlegendsten Anpassung müssen im Package kj.scotlyard.game.graph gemacht
 werden.
\end_layout

\begin_layout Enumerate
Zunächst müssen im GameGraph alle Vorkommen von
\begin_inset Newline newline
\end_inset

org.jgrapht.UndirectedGraph<StationVertex, ConnectionEdge>
\begin_inset Newline newline
\end_inset

abgeändert werden zur Graph-Schnittstelle des verwendeten Toolkits
\begin_inset Newline newline
\end_inset

OtherToolkitsGraphInterface<StationVertex, ConnectionEdge>
\end_layout

\begin_layout Enumerate
Außerdem definieren die Schnittstellen StationVertex und ConnectionEdge
 grundlegende Methoden, die den Zugriff auf den Graph vereinfachen und vereinhei
tlichen (siehe Bridge pattern).
 Die Implementierung in Station und Connection verwendet die original Graph-Schn
ittstelle, und muss bei Verwendung eines anderen Toolkits natürlich anders
 aussehen.
\end_layout

\begin_layout Subsubsection
Keine Änderungen im Model
\end_layout

\begin_layout Standard
Im Model (kj.scotlyard.game.model.*) muss nichts verändert werden, denn diese
 Klassen beziehen sich ausschließlich auf Knoten und Kanten des Graphen
 -- und diese sind ja in ScotlYard definiert; der Graph strukturiert sie
 nur.
\end_layout

\begin_layout Subsubsection
Keine Änderungen im Controller
\end_layout

\begin_layout Standard
Im Controller (kj.scotlyard.game.control.*) muss ebenfalls nichts verändert
 werden.
 Diese Klassen beziehen sich nur auf das Model und wenden dabei Regeln an.
 Den Regeln muss der Graph (in Form des GameGraph) zwar übergeben werden,
 aber was sich hinter GameGraph verbirgt interessiert den Controller nicht.
\end_layout

\begin_layout Subsubsection
Änderungen in Regeln
\end_layout

\begin_layout Standard
Das Interface in kj.scotlyard.game.rules.* ändert sich ebenfalls nicht.
 In der Implementierung der Regeln wird aber under Umständen auf den Graphen
 zugegriffen, denn die Regeln testen zum Beispiel, ob durch einen Zug der
 angegebene Knoten überhaupt erreichbar ist.
\end_layout

\begin_layout Standard
Würde die Implementierung mit dem Interface von StationVertex und ConnectionEdge
 auskommen, wären auch hier keine Änderungen notwendig.
 Wird aber auf das Interface der original Graph-Schnittstelle zurückgegriffen,
 müssen Anpassungen durchgeführt werden.
\end_layout

\begin_layout Subsubsection
Änderungen in AI
\end_layout

\begin_layout Standard
Auch hier ändern sich die Schnittstellen in kj.scotlyard.game.ai.* nicht, die
 Implementierung aber wahrscheinlich schon.
 Die AI lebt schließlich von Operationen im Graph und wird sich dabei nicht
 auf die schmale Schnittstelle von StationVertex und ConnectionEdge beschränken.
\end_layout

\begin_layout Subsubsection
Änderungen in Utilities
\end_layout

\begin_layout Standard
Einige Utilities (kj.scotlyard.game.utils.*), die eventuell mit dem GameGraph
 arbeiten, müssen angepasst werden.
 Dazu gehört vielleicht der MrXTracker.
\end_layout

\begin_layout Chapter
Controller und Rules
\end_layout

\begin_layout Standard
Der Controller steuert den Zugriff auf das Model.
 Er verhindert, dass es zu einem inkonsistenten Zustand im Model kommt,
 indem er die Regeln anwendet.
\end_layout

\begin_layout Section
Controller
\end_layout

\begin_layout Standard
Über den Controller (oder GameController) lässt sich das Spiel steuern.
 Der Controller kennt zwei Zustände: IN_GAME und NOT_IN_GAME.
\end_layout

\begin_layout Standard
Der DefaultGameController implementiert die GameController-Schnittstelle
 und verwendet das State pattern.
 Die gesamte Implementierung liegt im Package \SpecialChar \ldots{}
.control.impl.
 Der DefaultGameController besitzt also für jeden der zwei Zustände eine
 GameController Instanz, an die er die meisten Aufrufe deligiert.
 Für die Gemeinsamkeiten der beiden konkreten GameController für die existiert
 die Basisklasse GameControllerState.
\end_layout

\begin_layout Subsection
move(Move)
\end_layout

\begin_layout Standard
Diese Methode für currentPlayer den angegebenen Zug aus.
 Der genaue Ablauf ist folgender:
\end_layout

\begin_layout Enumerate
Die MovePolicy überprüft den Zug.
 Bei einem ungültigen Zug wird mit der entsprechenden Exception abgebrochen.
 In diesem Fall entfallen die folgenden Schritte
\end_layout

\begin_layout Enumerate
Der Zug wird der MoveList des GameState hinzugefügt und dabei versiegelt
 (
\begin_inset Formula $\rightarrow$
\end_inset

 seal()).
 Dabei werden die MoveListener informiert.
\end_layout

\begin_layout Enumerate
Alle verwendeten Items werden gemäß den Regeln weitergegeben bzw.
 weggeworfen.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Durch-die-TurnPolicy"

\end_inset

Durch die TurnPolicy werden Runde und Spieler (der als nächstes dran ist)
 ermittelt.
\end_layout

\begin_layout Enumerate
currentRoundNumber wird gemäß 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Durch-die-TurnPolicy"

\end_inset

 gesetzt und dabei werden die TurnListener informiert.
\end_layout

\begin_layout Enumerate
currentPlayer wird gemäß 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Durch-die-TurnPolicy"

\end_inset

 gesetzt und dabei werden die TurnListener informiert.
\end_layout

\begin_layout Enumerate
Der GameWin wird ermittelt (NO, MRX_WINS, DETECTIVES_WIN), und entsprechend
 der Zustand des Controllers gesetzt.
 Dabei werden -- wenn sich der Zustand ändert -- auch die Observer informiert.
\end_layout

\begin_layout Section
Regeln
\end_layout

\begin_layout Subsection
Grundprinzipien
\end_layout

\begin_layout Standard
Es muss wenige Grundprinzipien im Spiel geben, damit Regeln überhaupt Sinn
 machen und die Abtrennung vom Rest funktioniert.
 Diese Grundregeln sind (mindestens) Folgende:
\end_layout

\begin_layout Itemize
Mr.
 X muss existieren
\end_layout

\begin_layout Itemize
Player werden 
\emph on
vor
\emph default
 Spielbeginn festgelegt (Ausnahmen sind (Implementierungs-)Sache des Controllers
)
\end_layout

\begin_layout Itemize
Player müssen ziehen, wenn sie dran sind
\end_layout

\begin_layout Itemize
Beim Move eingesetzte Items müssen (evtl.) weitergegeben werden
\end_layout

\begin_layout Standard
Alles andere sollten die Regeln unmissverständlich regeln.
 Die Referenzimplementierung zur richtigen Anwendung der Rules findet sich
 im GameController.
\end_layout

\begin_layout Subsection
Anwendung der Regeln
\end_layout

\begin_layout Subsubsection
Spielbeginn
\end_layout

\begin_layout Subsubsection
Spielzüge
\end_layout

\begin_layout Itemize
movePolicy.checkMove(gameState, move)
\end_layout

\begin_layout Itemize
Items weitergeben: movePolcy.getNextItemOwner(gameState, move, item)
\end_layout

\begin_layout Itemize
Move zur Liste hinzufügen: gameState.getMoves().add(move)
\end_layout

\begin_layout Itemize
gameWinPolicy.isGameWon(gameState, gameGraph)
\end_layout

\begin_layout Itemize
turnPolicy.getNextPlayer/getNextRoundNumber
\end_layout

\begin_layout Itemize
gameState.setCurrentPlayer/setCurrentRoundNumber
\end_layout

\begin_layout Itemize
gameController.setState(gameStatus, gameWin)
\end_layout

\begin_layout Subsubsection
Spielende
\end_layout

\begin_layout Chapter
AI
\end_layout

\begin_layout Standard
Die künstliche Intelligenz kann für Detectives oder MrX Spielzüge vorschlagen.
 Hierzu baut ein kleines Framework auf die grundlegenden AI-Schnittstellen
 auf.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Schnittstellen, Hierarchie und Framework (Abstract...Ai) beschreiben!
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Utilities
\end_layout

\begin_layout Part
Standardimplementierung
\begin_inset Newline newline
\end_inset

(
\begin_inset Quotes gld
\end_inset

The Scotland Yard
\begin_inset Quotes grd
\end_inset

)
\end_layout

\begin_layout Section
Begriffe
\end_layout

\begin_layout Itemize
Initial Move
\end_layout

\begin_layout Itemize
Single Move
\end_layout

\begin_layout Itemize
Multi Move
\end_layout

\begin_layout Itemize
Base Move
\end_layout

\begin_layout Itemize
Sub Move
\end_layout

\begin_layout Part
Spiel-GUI (Projekt Board)
\end_layout

\begin_layout Standard
Das Eclipse-Projekt heißt Board (englisch ist für Spielbrett).
 In diesem Projekt sind auch die meisten Tests für den Core untergebracht,
 weil erst hier der echte Scotland Yard Graph geladen wird.
 Für die Tests brauchte ich den echten Graphen, um die Bewegungen nachvollziehen
 zu können.
\end_layout

\begin_layout Chapter
GUI-Komponenten
\end_layout

\begin_layout Section
MovePreparationBar
\end_layout

\begin_layout Section
BoardPanel
\end_layout

\begin_layout Standard
Das BoardPanel ist das JPanel, das das Spielfeld anzeigt.
 Das Spielfeld besteht aus dem Bild/der Karte, den VisualComponents des
 Graphen (bis jetzt nur VisualStations), den Pieces (Spielfiguren) und Markierun
gen, die irgendwie gezeichnet werden.
\begin_inset Note Note
status open

\begin_layout Plain Layout
wie ist das mit den markierungen?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um alles richtig darstellen zu können, braucht das BoardPanel:
\end_layout

\begin_layout Itemize
Rules
\begin_inset Newline newline
\end_inset

genauer gesagt GameStateAccessPolicy, dass MrX zur richtigen Zeit sichtbar
 gemacht werden kann
\end_layout

\begin_layout Itemize
GameState
\end_layout

\begin_layout Itemize
GameGraph
\end_layout

\begin_layout Itemize
Image
\begin_inset Newline newline
\end_inset

das Hintergrundbild/die Karte
\end_layout

\begin_layout Itemize
MovePreparer
\begin_inset Newline newline
\end_inset

dass Züge per Maus vorbereiteten werden können
\end_layout

\begin_layout Standard
Außerdem hat das BoardPanel die Eigenschaft mrXAlwaysVisible, die angibt,
 ob MrX immer sichtbar ist, oder nur wenn es die Regeln erlauben.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Sind die Regeln nicht gegeben d.
\begin_inset space \thinspace{}
\end_inset

h.
 null, ist MrX immer sichtbar.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die VisualComponents werden dem BoardPanel -- wie andere Child-Components
 auch -- einfach mit add(...) hinzugefügt.
 Intern benötigt das BoardPanel aber Verwaltungsstrukturen wie die visualStation
s-Map, die StationVertex auf VisualStation abbildet.
 Diese muss erzeugt werden, wenn mit add alle VisualComponents hinzugefügt
 wurden.
 Dazu dient die Methode buildVisualStationMap().
 Eleganter wäre es wohl, die add-Methoden zu überschreiben, und die VisualStatio
ns sofort der Map hinzuzufügen.
 Da gab es aber irgendwelche Probleme.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Kann sein, dass es einfach zu viele Methoden waren, die Childs hinzufügen
 oder entfernen, und ich Angst hatte, alle zu überschreiben, weil ich welche
 vergessen könnte.
 Außerdem rufen sich verschiedene add-Methoden eventuell (implementierungs-abhän
gig) gegenseitig auf; darauf kann man sich aber nicht verlassen.
\end_layout

\end_inset


\end_layout

\begin_layout Section
HistoryPanel
\end_layout

\begin_layout Chapter
Konzepte
\end_layout

\begin_layout Section
MovePreparation
\end_layout

\begin_layout Standard
MovePreparation ist die Vorbereitung von Zügen.
 ScotlYard ist wie das original Scotland Yard zwar rundenbasiert, Züge sollen
 aber vorbereitet werden können, damit z.
\begin_inset space \thinspace{}
\end_inset

B.
 die Detectives jede Runde 
\emph on
gemeinsam
\emph default
 ihre Strategie planen können.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Bedienung des MovePreparer.png
	width 16cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bedienkonzept-für-MovePreparatio"

\end_inset

Bedienkonzept für MovePreparation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie aus der Grafik 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bedienkonzept-für-MovePreparatio"

\end_inset

 ersichtlich, besteht das Vorbereiten eines Zugs immer aus dem Auswählen
 eines Spielers und dem Festlegen der nächsten Station(en).
 Implementiert ist dieses Konzept in der Klasse MovePreparer.
\end_layout

\begin_layout Standard
Im Folgenden muss zwischen zwei Ausdrücken unterschieden werden:
\end_layout

\begin_layout Itemize
selected Player / ausgewählter Spieler
\begin_inset Newline newline
\end_inset

Der Spieler, für den momentan der Zug vorbereitet wird; Wird mit selectPlayer
 festgelegt.
\end_layout

\begin_layout Itemize
current Player / Spieler, der gerade dran ist
\begin_inset Newline newline
\end_inset

Der Spieler, der gemäß GameState.getCurrentPlayer() gerade am Zug ist.
\end_layout

\begin_layout Subsection
MovePreparer
\end_layout

\begin_layout Standard
Der MovePreparer stellt also eine Schnittstelle zur Verfügung, um Züge für
 Spieler vorzubereiten.
 Er führt die Züge aber nicht selbst aus.
 Außerdem lässt er sich als Model einer MVC-Architektur verstehen: Er ist
 ein Subclass von observable.
 Wenn sich
\end_layout

\begin_layout Itemize
der ausgewählte Spieler ändert oder
\end_layout

\begin_layout Itemize
für einen Zug, der gerade vorbereitet wird, die nächste Station eingereicht
 wird,
\end_layout

\begin_layout Standard
werden alle Observer darüber informiert.
 Das Argument der update Methode der Observer ist dabei je nachdem der Player
 oder der Move.
 Auf seine Daten lässt sich mit den Methoden getSelectedPlayer und getMove
 zugreifen.
\end_layout

\begin_layout Standard
Der MovePreparer besitzt des Weiteren die Methoden selectPlayer(Player)
 und nextStation(Station).
 Das ist die Schnittstelle zum Vorbereiten der Züge und gleichzeitig sind
 es Setter für die Daten des Model.
\end_layout

\begin_layout Standard
Der MovePreparer ist natürlich so programmiert, dass er möglichst nur gültige
 Züge vorbereitet.
 Er macht also eine GUI-seitige Prüfung von Spieler und Station.
 Beim Ausführen des Zuges wird dieser nochmal von der MovePolicy geprüft.
 Dabei gibt es im Fall eines ungültigen Zuges eine MoveException.
 Deshalb wird vom MovePrepaerer im Vorhinein versucht, fehlerhafte Züge
 zu vermeiden.
 Es heißt hier 
\begin_inset Quotes gld
\end_inset

versuchen
\begin_inset Quotes grd
\end_inset

, weil ein Move nur von den Regeln, und wenn er ausgeführt wird, hunderprozentig
 geprüft werden kann.
\end_layout

\begin_layout Subsubsection
selectPlayer
\end_layout

\begin_layout Standard
Hiermit wird der Spieler ausgewählt.
 Es stecken aber gewisse Regln dahinter.
 Wenn ein Spieler nicht ausgewählt werden kann, wird die Methode errorSelectingP
layer aufgerufen.
 Hierin wird der Fehler behandelt bzw.
 Feedback an den Benutzer gegeben.
\end_layout

\begin_layout Standard
In folgenden Fällen kann der angegebene Spieler (player) nicht ausgewählt
 werden:
\end_layout

\begin_layout Enumerate
fixedTurnOrder && player != currentPlayer
\begin_inset Newline newline
\end_inset

Die Einstellung fixedTurnOrder bedeutet, dass die Detektive nicht gemeinsam
 ihre Züge vorbereiten können, sondern wirklich immer nur einer nach dem
 anderen dran ist.
\begin_inset Newline newline
\end_inset

Wenn man bei dieser Einstellung also versucht einen anderen Spieler auszuwählen,
 als den der an der Reihe ist wird player nicht ausgewählt.
\end_layout

\begin_layout Enumerate
currentPlayer instanceof MrXPlayer && player != currentPlayer
\begin_inset Newline newline
\end_inset

Wenn MrX gerade dran ist, und versucht wird, einen anderen Spieler auszuwählen,
 wird player nicht ausgewählt.
\end_layout

\begin_layout Enumerate
player hat in dieser Runde schon gezogen (den Zug nur vorbereitet, sondern
 auch ausgeführt!)
\begin_inset Newline newline
\end_inset

Wenn also der Spieler in dieser Runde schon dran war, kann er nicht nochmal
 ausgewählt werden.
\end_layout

\begin_layout Subsubsection
nextStation
\end_layout

\begin_layout Standard
Hiermit wird die nächste Station für den ausgewählten Spieler dem Zug, der
 gerade vorbereitet wird, hinzugefügt.
 
\end_layout

\begin_layout Standard
Ist die nächste Station aus irgendeinem Grund ungültig, macht die Template-Metho
de nextStation Callback an die Methode errorImpossibleNextStation.
 Läuft alles gut, gibt es einen Callback an selectTicket, um den Benutzer
 ein Ticket auswählen zu lassen.
 Wird kein Ticket ausgewählt (selectTicket returns null), wird die der Aufruf
 abgebrochen.
\end_layout

\begin_layout Subsubsection
reset
\end_layout

\begin_layout Standard
Hiermit wird für den angegebenen Spieler der Zug, der gerade in Vorbereitung
 ist, zurückgesetzt.
 Mit resetAll geschieht das für die Züge aller Spieler.
\end_layout

\begin_layout Subsection
Das Bedienkonzept
\end_layout

\begin_layout Standard
Wie ebenfalls aus der Grafik 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bedienkonzept-für-MovePreparatio"

\end_inset

 ersichtlich, sind folgende Möglichkeiten zum Vorbereiten von Zügen vorgesehen:
\end_layout

\begin_layout Enumerate
Via MovePreparationBar (Nummerneingabe)
\begin_inset Newline newline
\end_inset

Hier wählt man im Kombinationsfeld den Spieler aus, gibt die Nummer der
 nächsten Station ein und bestätigt dann mit OK.
\end_layout

\begin_layout Enumerate
Zwei Klicks
\begin_inset Newline newline
\end_inset

Man wählt durch den ersten Klick den Spieler aus, durch den zweiten Klick
 die Station, auf die dieser ziehen soll.
 Ist der gewünschte Spieler bereits ausgewählt, kann auf den ersten Klick
 verzichtet werden.
\end_layout

\begin_layout Enumerate
Drag & Drop
\begin_inset Newline newline
\end_inset

Klassisches Drag & Drop: Den Spieler einfach auf die gewünschte Station
 ziehen.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Ein-KlickDurch-einen"

\end_inset

Ein Klick
\begin_inset Newline newline
\end_inset

Durch einen Klick auf eine Station wird 
\emph on
automatisch
\emph default
 der nächste Spieler ausgewählt, für den dann der Zug auf diese Station
 vorbereitet wird.
\begin_inset Foot
status open

\begin_layout Plain Layout
Der genaue Algorithmus ist weiter unten beschrieben.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Klingt erst mal gut, doch bei der Eingabe mit Mausklicks im BoardPanel ergeben
 sich einige Problem.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Ein-Klick-auf"

\end_inset

Ein Klick auf einen Spieler kann bedeuten
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Quotes gld
\end_inset

diesen Spieler auswählen
\begin_inset Quotes grd
\end_inset

 oder
\end_layout

\begin_layout Enumerate
\begin_inset Quotes gld
\end_inset

auf die Station ziehen, auf der dieser Spieler steht
\begin_inset Quotes grd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Die automatische Auswahl eines Spielers durch nur einen Klick 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Ein-KlickDurch-einen"

\end_inset

 ist nicht trivial:
\end_layout

\begin_deeper
\begin_layout Enumerate
Bei Multi Moves reicht es nicht nach direkten Nachbarn zu sehen.
\end_layout

\begin_layout Enumerate
Unterscheidung zwischen MrX und Detektiven.
\end_layout

\begin_layout Enumerate
Was tun bei Mehrdeutigkeit?
\end_layout

\begin_layout Enumerate
Was tun bei Mehrdeutigkeit, wenn aber der ausgewählte Spieler unter den
 in Frage kommenden Spielern ist?
\end_layout

\end_deeper
\begin_layout Standard
Bei dem Bedienkonzept muss man hinsichtlich dieser Probleme Abstriche in
 Kauf nehmen.
 Das Bedienkonzept per Mausklicks ist nun implementiert wie in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Klick-auf-Spieler"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "par:Klick-auf-Spieler"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Klick-auf-Station"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "par:Klick-auf-Station"

\end_inset

 beschrieben.
 Abhilfe zum 1.
 Problem 
\begin_inset CommandInset ref
LatexCommand eqref
reference "enu:Ein-Klick-auf"

\end_inset

 schafft in manchen Fällen nur Nummerneingabe oder Drag & Drop.
\end_layout

\begin_layout Subsubsection
MovePreparationBar
\end_layout

\begin_layout Standard
Dabei handelt es sich um die Leiste in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bedienkonzept-für-MovePreparatio"

\end_inset

, mit der (ohne Maus und Spielbrett) die Züge vorbereitet werden können.
\end_layout

\begin_layout Itemize
Im Kombinationsfeld wählt man den Spieler aus.
 Demnach wird der Wert im Model (d.
\begin_inset space \thinspace{}
\end_inset

h.
 im MovePreparer) gesetzt.
 Kann der gewünschte Spieler nicht ausgewählt werden, informiert das Model
 die Observer über die (Nicht-)Änderung, so dass der ausgewählte Spieler
 im Kombinationsfeld sofort wieder auf den richtigen zurückgesetzt wird.
\end_layout

\begin_layout Itemize
Im Eingabefeld gibt man die Stationsnummer ein.
 Wenn MrX ausgewählt ist, ist das Textfeld wie ein Unix-Passwortfeld.
 Dort muss man die Nummer ohne jegliches Feedback eingeben.
\end_layout

\begin_layout Itemize
Mit dem Schalter OK bestätigt man die eingegebene Station.
 Dies bewirkt den Aufruf von nextStation.
\end_layout

\begin_layout Itemize
Mit dem Schalter Reset kann für den ausgewählten Spieler der vorbereitete
 Zug zurückgesetzt, also gelöscht werden, falls man sich vertan hat.
\end_layout

\begin_layout Subsubsection
BoardPanel
\end_layout

\begin_layout Standard
Probleme bzw.
 Schwierigkeiten:
\end_layout

\begin_layout Itemize
Klick auf Spieler kann bedeuten
\end_layout

\begin_deeper
\begin_layout Itemize
Spieler auswählen
\end_layout

\begin_layout Itemize
Vorher ausgewählten Spieler auf Station des angeklickten Spielers ziehen
\end_layout

\end_deeper
\begin_layout Itemize
Detectives können auf Station von MrX fahren, aber nicht umgekehrt
\end_layout

\begin_layout Standard
Um Klarheit zu schaffen werden jetzt folgende Algorithmen verwendet:
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Klick-auf-Spieler"

\end_inset

Klick auf Spieler
\end_layout

\begin_layout Standard
Im Normalfall soll hier der Spieler ausgewählt werden.
\end_layout

\begin_layout Standard
Wenn aber ein Detektiv ausgewählt ist und auf MrX geklickt wird, wird das
 Klick-Ereignis an die Station durchgereicht, auf der sich MrX befindet.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Klick-auf-Station"

\end_inset

Klick auf Station
\end_layout

\begin_layout Standard
Im Normalfall wird für den ausgewählten Spieler diese als nächste Station
 festgelegt.
\end_layout

\begin_layout Standard
Wenn aber ein Detektiv ausgewählt ist wird folgendes gemacht:
\end_layout

\begin_layout Enumerate
Detektive in der Nachbarschaft
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Der Radius ist im BoardPanel auf 1 hardgecoded, kann aber erhöht werden
 um bei Multi Moves angebracht zu reagieren, oder um Verwechslungen seitens
 des Benutzers zu vorzubeugen.
\end_layout

\end_inset

 der Zielstation ermitteln
\end_layout

\begin_layout Enumerate
Wenn sich der ausgewählte Detektiv in der Nachbarschaft befindet,
\end_layout

\begin_deeper
\begin_layout Enumerate
und er der einzige ist, bleibt er natürlich ausgewählt.
\end_layout

\begin_layout Enumerate
aber sich noch weitere Dektive in der Nachbarschaft befinden, könnte gefragt
 werden, ob man den ausgewählten meint.
 Wenn nicht, wird man aufgefordert, seinen Detektiv explizit auszuwählen.
\begin_inset Foot
status open

\begin_layout Plain Layout
Dieses Feature könnte aber nervig sein, deswegen ist es nicht implementiert.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Wenn sich genau ein Detektiv in der Nachbarschaft befindet, wird dieser
 ausgewählt (falls er sowieso schon der Ausgewählte war halt nochmal).
\end_layout

\begin_layout Enumerate
Wenn sich der ausgewählte Detektiv nicht in der Nachbarschaft befindet,
 aber dafür mehrere andere Detektive, kommt eine Meldung, dass zuerst ein
 Detektiv explizit ausgewählt werden muss.
\end_layout

\begin_layout Paragraph
Drag bei Spieler
\end_layout

\begin_layout Standard
Sobald ein Drag erkannt wird, wird versucht den Spieler auszuwählen (selectPlaye
r).
 Wenn das nicht erfolgreich war, wird 
\emph on
überall
\emph default
 das no-drop-Cursor angezeigt.
\end_layout

\begin_layout Paragraph
Drop auf Station
\end_layout

\begin_layout Standard
Drop-Ziel kann entweder eine Station oder ein Spieler sein.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Hier muss wohl für alle Spieler und Stationen der 
\begin_inset Quotes gld
\end_inset

can-drop-Cursor
\begin_inset Quotes grd
\end_inset

 angezeigt werden.
 Ob die Station möglich ist, sieht man ja erst nach Aufruf von nextStation,
 also wenn die Maustaste losgelassen wurde.
\end_layout

\end_inset

 Beim Drop wird die Station (bzw.
 die Station unter dem Spieler) als nächste Station festgelegt (nextStation).
\end_layout

\begin_layout Part*
Anhang
\end_layout

\begin_layout Section
Eigennamen
\end_layout

\begin_layout Itemize
ScotlYard
\end_layout

\begin_layout Itemize
JGraphT
\end_layout

\end_body
\end_document
